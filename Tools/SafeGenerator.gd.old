@tool
extends Node

# --- CONFIGURATION S√âCURIS√âE ---
@export_group("Setup")
@export var terrain_node: Terrain3D
@export var loading_screen_scene: PackedScene = preload("res://UI/LoadingScreen.tscn")

@export_group("Style: Hyrule & Teyvat")
@export var biome_scale: float = 0.0015 # Plus large
@export var height_scale: float = 240.0 # Plus haut
@export var terrace_height: float = 8.0 # Marches plus fines
@export var cliff_steepness: float = 0.95 # Falaises tr√®s nettes
@export var noise_seed: int = 42

@export_group("Actions")
@export var force_reset: bool = false # Cochez pour r√©g√©n√©rer le monde
@export var generer_en_douceur: bool = false : set = _on_button_generate
@export var folder_assets: String = "res://Assets/"

# UI Instance
var _ui_instance = null

func _ready():
	# Si on est dans l'√©diteur, on ne fait rien automatiquement
	if Engine.is_editor_hint(): return
	
	# YIELD STARTUP to allow window to appear
	await get_tree().process_frame
	await get_tree().process_frame
	
	print("\n‚úÖ LIVE V2: SafeGenerator Ready (Double-Reset Fix)")
	
	if not terrain_node:
		# Auto-d√©tection
		var t = get_parent().find_child("Terrain3D", true, false)
		if t: terrain_node = t
		else: print("‚ö†Ô∏è Terrain3D non trouv√© automatiquement. Assurez-vous qu'il est dans la sc√®ne !")

	# V√©rifier sauvegarde (Priorit√© user:// car c'est l√† qu'on √©crit si res:// √©choue)
	# IMPORTANT: On utilise .res (BINAIRE) au lieu de .tres (TEXTE) pour √©viter le lag monstrueux au chargement
	var save_path_res = "res://Assets/Terraindata/GeneratedStorage_AirWorld.res"
	var save_path_user = "user://GeneratedStorage_AirWorld.res"
	var path_to_load = ""
	
	# Compatibilit√© arri√®re : Si un .tres existe, on ignore ou on le supprime (car trop lent)
	if FileAccess.file_exists("user://GeneratedStorage.tres"):
		print("‚ö†Ô∏è Vieux fichier .tres d√©tect√©. Ignor√© pour performance.")
		# DirAccess.remove_absolute("user://GeneratedStorage.tres") 
	
	if FileAccess.file_exists(save_path_user):
		path_to_load = save_path_user
	elif FileAccess.file_exists(save_path_res):
		path_to_load = save_path_res
	
	# Gestion du Reset Force
	if force_reset:
		print("‚ôªÔ∏è RESET DEMAND√â. Nettoyage physique des fichiers...")
		if FileAccess.file_exists(save_path_user): DirAccess.remove_absolute(save_path_user)
		if FileAccess.file_exists(save_path_res):  DirAccess.remove_absolute(save_path_res)
		path_to_load = "" 
	
	if path_to_load != "":
		print("üíæ Sauvegarde BINAIRE trouv√©e (" + path_to_load + ").")
		_load_existing_world(path_to_load)
	else:
		print("‚ú® Nouveau monde requis. D√©marrage de la s√©quence ASYNC s√©curis√©e.")
		_start_safe_generation_sequence()

func _load_existing_world(path):
	_show_loading_screen()
	_update_ui("Lecture du disque (Binaire)...", 0)
	
	# LOAD THREADED pour ne pas freezer le PC
	ResourceLoader.load_threaded_request(path)
	
	while ResourceLoader.load_threaded_get_status(path) == ResourceLoader.THREAD_LOAD_IN_PROGRESS:
		# On laisse respirer le thread principal
		await get_tree().process_frame
		_update_ui("Chargement des donn√©es...", 50)
		
	var status = ResourceLoader.load_threaded_get_status(path)
	if status == ResourceLoader.THREAD_LOAD_LOADED:
		var data = ResourceLoader.load_threaded_get(path)
		if terrain_node and data:
			_update_ui("Envoi vers GPU...", 80)
			await get_tree().process_frame
			
			terrain_node.set("data", data)
			terrain_node.set("storage", data)
			
			if terrain_node.has_method("notify_property_list_changed"):
				terrain_node.notify_property_list_changed()
				
			print("‚úÖ Chargement termin√©.")
	else:
		print("‚ùå Erreur chargement threaded. Fallback regeneration.")
		_start_safe_generation_sequence()
		return

	_update_ui("Pr√©paration...", 100)
	await get_tree().create_timer(0.2).timeout
	_hide_loading_screen()
	_teleport_player()

func _print_debug_state():
	print("\nüîç --- DEBUT ANALYSE DIAGNOSTIQUE (Deep Analysis) ---")
	if not terrain_node:
		print("‚ùå ERREUR: terrain_node est NULL.")
		return

	print("üìç Noeud: " + str(terrain_node.get_path()))
	print("‚ùì Visible: " + str(terrain_node.visible))
	
	# Check Storage
	var d = terrain_node.get("data")
	if not d: d = terrain_node.get("storage")
	
	if d:
		print("‚úÖ Data/Storage Object: " + str(d))
		if d.has_method("get_region_count"):
			print("   üìä Regions Count: " + str(d.get_region_count()))
		if d.has_method("get_regions_active"):
			print("   üìç Active Regions: " + str(d.get_regions_active()))
	else:
		print("‚ùå ERREUR: Data/Storage est NULL !")

	# Check Assets
	var a = terrain_node.assets
	if a:
		print("‚úÖ Assets Object: " + str(a))
		if a.has_method("get_texture_count"):
			var tc = a.get_texture_count()
			print("   üé® Textures Count: " + str(tc))
			if tc == 0:
				print("   ‚ö†Ô∏è AVERTISSEMENT: 0 Textures ! Le terrain sera invisible/noir.")
	else:
		print("‚ùå ERREUR: Assets est NULL !")
		
	print("üîç --- FIN ANALYSE ---\n")
func _start_safe_generation_sequence():
	_show_loading_screen()
	await get_tree().process_frame
	_print_debug_state()
	
	# 1. SETUP
	_update_ui("Initialisation...", 5)
	
	var mat = terrain_node.get("material")
	if mat:
		# FORCE ALL DEBUG OFF AGGRESSIVELY
		var props = {
			"show_region_grid": false, "show_instancer_grid": false, "show_vertex_grid": false,
			"show_contours": false, "show_navigation": false, "show_checkered": false,
			"show_grey": false, "show_jaggedness": false, "show_colormap": false,
			"show_heightmap": false, "show_roughmap": false, "show_control_texture": false,
			"show_texture_height": false, "show_texture_normal": false, "show_texture_rough": false,
			"show_autoshader": false # NEVER USE AUTOSHADER
		}
		for p_name in props:
			if mat.get(p_name) == null: continue
			mat.set(p_name, props[p_name])
			# Also try shader params just in case
			# Removed invalid call

		mat.set("world_background", 0) 
		print("‚úÖ Material Reset (Full Aggressive). Debugs OFF.")
	
	# MASQUER LE MONDE PENDANT LA G√âN√âRATION
	var world = get_parent().find_child("GameWorld", true, false)
	if world: world.visible = false
	
	_ensure_lighting()
	_ensure_theme_assets()
	var data = _ensure_data()
	
	_print_debug_state() # D√©plac√© APRES le setup pour voir les textures
	
	if not data: return # Erreur grave
	
	# Force Collision (Removed invalid property)
	# if terrain_node:
	#	terrain_node.call("update_collision") # Tentative alternative safe

	
	# 2. SCULPTURE DOUCE
	await _sculpt_terrain_async(data)
	
	# 3. D√âCORATION DOUCE
	await _decorate_terrain_async(data)
	_spawn_towers(data)
	
	# 4. SAUVEGARDE & FIN (Move to ASYNC to avoid hangs)
	_update_ui("Sauvegarde finale...", 92)
	await get_tree().process_frame
	
	var save_path_res = "res://Assets/Terraindata/GeneratedStorage_AirWorld.res"
	var save_path_user = "user://GeneratedStorage_AirWorld.res"
	
	# Explicit reference pinning
	var final_data = data
	if not final_data: final_data = terrain_node.get("data")
	if not final_data: final_data = terrain_node.get("storage")
		
	if final_data and is_instance_valid(final_data) and final_data is Resource:
		print("üíæ D√©marrage Sauvegarde... Objet: ", final_data)
		# TENTATIVE 1: USER (Safe Area)
		var err = ResourceSaver.save(final_data, save_path_user)
		if err == OK:
			print("‚úÖ Monde sauvegard√© (USER ok)")
			# TENTATIVE 2: PROJECT (Fails if editor is locked, ignore errors)
			ResourceSaver.save(final_data, save_path_res)
		else:
			print("‚ö†Ô∏è Echec sauvegarde User (" + str(err) + ").")
	else:
		print("‚ùå DATA INVALIDE pour sauvegarde.")

	# 5. ULTIMATE GPU SYNC (The "Wake Up" call)
	if terrain_node:
		print("‚ò¢Ô∏è ULTIMATE SYNC : Reconstruction Mesh & Shaders...")
		# Detach/Reattach for total reset
		terrain_node.set("storage", null)
		await get_tree().process_frame
		terrain_node.set("storage", final_data)
		
		if terrain_node.has_method("notify_property_list_changed"):
			terrain_node.notify_property_list_changed()
		
		# Forcer l'update visuel agressif
		if final_data.has_method("force_update_terrain"):
			final_data.force_update_terrain(7) # 7 = Everything
		
		print("‚ò¢Ô∏è ULTIMATE SYNC : Termin√©.")
	
	_teleport_player()
	
	# 5. SPAWN ENEMIES (ASYNC)
	_spawn_enemies_async(data)

	# R√â-AFFICHER LE MONDE
	var world_end = get_parent().find_child("GameWorld", true, false)
	if world_end: world_end.visible = true
	
	_hide_loading_screen()

# --- COEUR ASYNCHRONE ---

func _sculpt_terrain_async(data):
	print("‚õ∞Ô∏è D√©but Sculpture Async...")
	_update_ui("Sculpture du terrain...", 10)
	
	# Noise Setup
	var noise_base = FastNoiseLite.new(); noise_base.seed = noise_seed; noise_base.frequency = 0.001
	var noise_mount = FastNoiseLite.new(); noise_mount.seed = noise_seed+1; noise_mount.frequency = 0.003
	var noise_warp = FastNoiseLite.new(); noise_warp.seed = noise_seed+2; noise_warp.frequency = 0.01
	
	# NOISE RIVI√àRE (Winding Paths)
	var noise_river = FastNoiseLite.new(); noise_river.seed = noise_seed+3; noise_river.frequency = 0.0008
	noise_river.noise_type = FastNoiseLite.TYPE_PERLIN
	var noise_ridges = FastNoiseLite.new(); noise_ridges.seed = noise_seed+4; noise_ridges.frequency = 0.005; noise_ridges.fractal_type = FastNoiseLite.FRACTAL_RIDGED
	var noise = FastNoiseLite.new(); noise.seed = noise_seed+5; noise.frequency = 0.002
	
	var active_regions = []
	if data.has_method("get_regions_active"):
		active_regions = data.get_regions_active()
	
	if active_regions.is_empty():
		# Fallback si vraiment rien (mais normalement _ensure_data a cr√©√© 0,0)
		active_regions = [Vector2i(0,0)]
	
	# 3. SCULPTURE DIRECTE SUR IMAGE (Bypass API Lookup)
	var processed_regions = 0
	
	for region in active_regions:
		processed_regions += 1
		
		# Identifier la position de la r√©gion
		var rx = 0
		var ry = 0
		if region is Vector2i:
			rx = region.x
			ry = region.y
			# Si c'est un Vector2i, on ne peut pas √©diter l'image directement sans r√©cup√©rer l'objet...
			# Mais active_regions devrait retourner des Objets maintenant.
			if data.has_method("get_region"):
				region = data.get_region(region) 
		
		if not is_instance_valid(region) or not region.has_method("get_location"):
			print("‚ö†Ô∏è R√©gion invalide ou API inconnue, skip.")
			continue
			
		var loc = region.get_location()
		rx = loc.x
		ry = loc.y
		
		# Detect correct size from existing maps if possible
		var r_size = 1024 
		var existing_h = region.get("height_map")
		if existing_h: r_size = existing_h.get_width()
		
		# FRESH IMAGES in correct formats
		# Height MUST be FORMAT_RF for Terrain3D to work without being black
		var h_map = Image.create(r_size, r_size, false, Image.FORMAT_RF)
		if h_map.get_format() != Image.FORMAT_RF:
			h_map.convert(Image.FORMAT_RF)
			
		var c_map = Image.create(r_size, r_size, false, Image.FORMAT_RGBA8)
		if c_map.get_format() != Image.FORMAT_RGBA8:
			c_map.convert(Image.FORMAT_RGBA8)
			
		var a_map = Image.create(r_size, r_size, false, Image.FORMAT_RGBA8)
		
		# CRITICAL FIX: Ensure not compressed (though create() shouldn't be, engine behavior varies)
		if h_map.is_compressed(): h_map.decompress()
		if c_map.is_compressed(): c_map.decompress()
		
		a_map.fill(Color(1, 1, 1, 1)) # Pure white
			
			
		var start_x_world = rx * r_size # Offset Global
		var start_z_world = ry * r_size
		
		print("üé® Sculpture R√©gion " + str(loc) + " (Direct Image Access)")
		
		# Boucle Pixels (Local Space 0..1024)
		print("üîç Image Format (H): " + str(h_map.get_format()) + " (Target RF: " + str(Image.FORMAT_RF) + ")")
		
		for x in range(0, r_size):
			# FLUIDITY: Pause every single line for weak CPUs/Integrated graphics
			_update_ui("Sculpture R" + str(loc) + " " + str(int(float(x)/r_size*100)) + "%...", 20.0 + (float(processed_regions)/active_regions.size() * 30.0))
			await get_tree().process_frame
			
			for y in range(0, r_size): # Y est Z en 3D
				# Coordonn√©es Globales pour le Bruit
				var wx = start_x_world + x
				var wz = start_z_world + y
				
				# Ajout warping l√©ger
				var ns_x = wx + noise_warp.get_noise_2d(wx, wz) * 50.0
				var ns_z = wz + noise_warp.get_noise_2d(-wx, wz) * 50.0
				
				# Calcul Hauteur Principal
				var base_h = noise_base.get_noise_2d(ns_x, ns_z) 
				var mount_h = noise_mount.get_noise_2d(ns_x, ns_z)
				
				# RIVI√àRES (Winding Valleys)
				var riv_v = abs(noise_river.get_noise_2d(wx, wz)) 
				var riv_depth = smoothstep(0.08, 0.0, riv_v) * 40.0 # Creuse jusqu'√† 40m
				
				# COMBINAISON (Reduced for better exploration)
				var final_h = base_h * 80.0 
				if base_h > 0.0:
					final_h += mount_h * 100.0 * smoothstep(0.0, 0.5, base_h)
				
				# Soustraire la rivi√®re
				final_h -= riv_depth
				
				# ROADS TO TOWERS (Logic)
				# Center (0,0) to towers at region centers
				var dist_to_center = Vector2(wx, wz).length()
				var road_factor = 0.0
				
				# Simple road logic: If near X=0 or Z=0 cross (approximate roads)
				if abs(wx) < 15.0 or abs(wz) < 15.0:
					if dist_to_center < 1200: # Road within reasonable range
						road_factor = smoothstep(15.0, 5.0, min(abs(wx), abs(wz)))
				
				# Flatten road
				final_h = lerp(final_h, -5.0, road_factor * 0.8)
				
				# Terrasses (Zelda Style)
				var steps = final_h / terrace_height
				var i_step = floor(steps)
				var f_step = steps - i_step
				var t = clamp((f_step - 0.5) / (1.0 - cliff_steepness) + 0.5, 0.0, 1.0)
				t = t * t * (3.0 - 2.0 * t) 
				var aesthetic_h = (i_step + t) * terrace_height
				
				# --- 10 BIOMES SPLATTING ---
				var tex_id = 0
				
				# BIOMES DYNAMIC (Zelda/Genshin Logic)
				var temp = noise_ridges.get_noise_2d(wx * 0.1, wz * 0.1)
				var humid = noise.get_noise_2d(wx * 0.05 + 500, wz * 0.05 + 500)
				
				# RIVI√àRE PRIORIT√â (Gravel/Sand bed)
				if riv_v < 0.04:
					tex_id = 4 # Lightning Gravel (Blue rocky bed)
				elif road_factor > 0.4:
					tex_id = 4 # Gravel road
				# TEXTURE SPLATTING (Biome Mapping)
				elif final_h > height_scale * 0.5: # MOUNTAINS
					if temp < -0.2: tex_id = 9 # Snow
					else: tex_id = 8 # Crystal/White Rock
				elif final_h < -10.0: # WATER/LAVA BEDS
					if temp > 0.3: tex_id = 6 # Lava
					else: tex_id = 4 # Gravel/River Bed
				else: # GREEN LANDS
					if humid > 0.2: tex_id = 1 # Forest
					elif humid < -0.2: tex_id = 5 # Desert
					elif temp > 0.4: tex_id = 7 # Gold (Autumnal)
					else: tex_id = 3 # Lush Grass
				
				# --- MASSIVE PROOF-OF-LIFE PILLAR at (0,0) ---
				# SUPPRIM√â : Le terrain fonctionne, on laisse la nature reprendre ses droits.
				# --------------------------------------------
				
				# √âcriture Directe Pixel (Hauteur)
				h_map.set_pixel(x, y, Color(aesthetic_h, 0, 0, 1))
				
				c_map.set_pixel(x, y, Color(float(tex_id)/255.0, 0, 0, 1))
		
		# API-SAFE Map Assignment
		if "height_map" in region: region.height_map = h_map
		else: region.set("height_map", h_map)
		
		if "control_map" in region: region.control_map = c_map
		else: region.set("control_map", c_map)
		
		if "color_map" in region: region.color_map = a_map
		else: region.set("color_map", a_map)
		
		# UPDATED: No more import_images (causes layered texture mismatch crash/lag)
		# We use data.force_update_terrain(7) at the end for global sync.
		
		# CRITICAL: Force GPU Update PER REGION to ensure visibility
		if data.has_method("notify_region_modified"):
			data.notify_region_modified(region.get_location())
		elif data.has_method("update_heights"):
			data.update_heights(region)
			data.update_control(region)
		
		print("üíæ Region " + str(loc) + " : Masterpiece Sync. Format H: " + str(h_map.get_format()))
		
	print("‚úÖ Sculpture termin√©e (M√©moire). Envoi GPU...")
	
	# DEBUG: V√©rifier si l'image a bien √©t√© √©crite
	if not active_regions.is_empty():
		# On check la premi√®re r√©gion
		var _check_h: Image = active_regions[0].height_map if active_regions[0] is Object else null
		# Si active_regions[0] est Vector2i, il faut r√©cup√©rer l'objet... (compliqu√© ici)
		# Bref, on fait confiance au script pr√©c√©dent.
		# On va juste print un message confirmant qu'on passe √† l'update.
	
	# FORCE SYNC NUKE (GPU RE-UPLOAD)
	if terrain_node: 
		# Rattachement explicite
		terrain_node.set("storage", data)
		
		# Forcer la reconstruction compl√®te du mesh et des textures
		if data.has_method("force_update_terrain"):
			print("‚ò¢Ô∏è GPU REBUILD: force_update_terrain(7)...")
			data.force_update_terrain(7) # 7 = Everything
		elif data.has_method("update_heights"):
			data.update_heights()
			data.update_control()

		
		if terrain_node.has_method("request_mesh_update"):
			terrain_node.request_mesh_update()
			
	# ---------------------------------------------------------
	# NUCLEAR RELOAD (The Ultimate Fix for Intel Iris Xe)
	# We save the data to disk and load it back. This forces
	# the engine to rebuild everything from scratch.
	# ---------------------------------------------------------
	print("‚ò¢Ô∏è NUCLEAR RELOAD: Saving to disk to force GPU sync...")
	_update_ui("Synchronisation GPU (Disque)...", 40)
	await get_tree().process_frame
	
	var fix_path = "user://temp_visual_fix.res"
	var err_save = ResourceSaver.save(data, fix_path)
	
	if err_save == OK:
		# Detach
		terrain_node.set("storage", null)
		await get_tree().process_frame
		
		# Reload
		if FileAccess.file_exists(fix_path):
			var loaded_data = load(fix_path)
			if loaded_data:
				loaded_data.take_over_path(fix_path) # Ensure uniqueness
				# Re-Attach
				terrain_node.set("storage", loaded_data)
				terrain_node.notify_property_list_changed()
				# Update reference
				data = loaded_data
				print("‚úÖ NUCLEAR RELOAD COMPLETE. Visuals should be perfect.")
			else:
				print("‚ùå RELOAD FAILED: Load returned null. Reverting to memory.")
				terrain_node.set("storage", data)
		else:
			print("‚ùå RELOAD FAILED: File not found. Reverting.")
			terrain_node.set("storage", data)
	else:
		print("‚ùå SAVE FAILED (" + str(err_save) + "). Skipping Nuclear Reload.")
	
	# Restore Material just in case
	var mat = terrain_node.get("material")
	if not mat:
		print("‚ö†Ô∏è Material missing. Creating new Terrain3DMaterial...")
		mat = ClassDB.instantiate("Terrain3DMaterial")
		if mat:
			terrain_node.set("material", mat)
		else:
			print("‚ùå FATAL: Could not instantiate Terrain3DMaterial. Visuals may be broken.")
		
		
	if mat:
		# Just force debugs off, DO NOT set to null (causes crashes)
		_force_disable_debugs(mat)
		
		# CRITICAL: Force Debug Off on the potentially new material
		_force_disable_debugs(mat)
		
	# FORCE MESH REBUILD
	if data.has_method("force_update_terrain"):
		data.force_update_terrain(7)
	if terrain_node.has_method("request_mesh_update"):
		terrain_node.request_mesh_update()
		
	print("‚úÖ NUCLEAR RELOAD COMPLETE. Visuals should be perfect.")
	
	# Update reference for decoration
	# data = loaded_data # REMOVED (Scope Fix)
	
	print("‚úÖ Sculpture termin√©e. Envoi GPU...")
	await get_tree().process_frame

func _force_visual_sync(data):
	print("‚ò¢Ô∏è FORCING VISUAL SYNC (Shader & GPU)...")
	if not terrain_node: return
	
	# 1. Shader Shake (Force Recompile)
	# 1. Shader Shake (Force Recompile)
	var mat = terrain_node.get("material")
	if not mat:
		print("‚ö†Ô∏è Material missing. Creating new Terrain3DMaterial...")
		mat = ClassDB.instantiate("Terrain3DMaterial")
		terrain_node.set("material", mat)
	
	terrain_node.set("material", null)
	await get_tree().process_frame
	terrain_node.set("material", mat)
	
	# 2. Force Debug Off
	if mat:
		# mat.set_shader_parameter("show_checkered", false) # Try shader param access too
		mat.set("show_checkered", false)
		mat.set("show_colormap", false) 
		mat.set("show_control_texture", false)
		mat.set("show_autoshader", false)
		
	# 3. Region Updates
	if data.has_method("get_regions_active"):
		var regions = data.get_regions_active()
		for r in regions:
			if data.has_method("update_heights"):
				data.update_heights(r)
				data.update_control(r)
				
	# 4. Global Update
	if data.has_method("force_update_terrain"):
		data.force_update_terrain(7)
	
	if terrain_node.has_method("request_mesh_update"):
		terrain_node.request_mesh_update()
	terrain_node.notify_property_list_changed()
	print("‚ò¢Ô∏è VISUAL SYNC DONE.")

func _decorate_terrain_async(data):
	print("üå≤ D√©but D√©coration Async...")
	_update_ui("Analyse des assets...", 50)
	await get_tree().create_timer(0.1).timeout
	
	# Make sure we await the new async function
	var assets = await _scan_assets_safe(folder_assets)
	
	# (Function definition removed from here)
	if assets["tree"].is_empty() and assets["rock"].is_empty():
		print("‚ö†Ô∏è Aucun asset trouv√© dans " + folder_assets)
		return

	# Nettoyage
	for c in get_children():
		c.queue_free()
	
	var forest_noise = FastNoiseLite.new(); forest_noise.seed = noise_seed + 99
	var region_size = 1024
	if data.has_method("get_region_size"): region_size = data.get_region_size()
	var active_regions = []
	if data.has_method("get_regions_active"): active_regions = data.get_regions_active()
	
	if active_regions.is_empty():
		print("‚ö†Ô∏è Aucune r√©gion √† d√©corer.")
		return
	
	var batch = {} # { "path": [Transforms...] }
	var total_lines = active_regions.size() * (region_size / 4) # Step 4
	var processed_lines = 0
	
	for region in active_regions:
		var rx = 0
		var ry = 0
		
		if region is Vector2i:
			rx = region.x
			ry = region.y
		elif region.has_method("get_location"):
			var l = region.get_location()
			rx = l.x
			ry = l.y
		else:
			continue
		
		var start_x = rx * region_size
		var start_z = ry * region_size
		
		# DEBUG: Verify Height Data
		var check_h = data.get_height(Vector3(start_x + 512, 0, start_z + 512))
		print("üîç Check Height Region " + str(region) + " center: " + str(check_h))
		
		# Pas de 4 pour perf -> 12 pour MAXIMUM PERF (Iris Xe)
		for x in range(start_x + 8, start_x + region_size - 8, 12):
			# ANTI-FREEZE
			# ANTI-FREEZE
			if processed_lines % 2 == 0: # Yield toutes les 2 lignes (environ)
				await get_tree().process_frame
				var p = 50.0 + (float(processed_lines)/total_lines) * 40.0 # 50% -> 90%
				_update_ui("V√©g√©tation...", p)
			processed_lines += 1
			
			for z in range(start_z + 8, start_z + region_size - 8, 12):
				var h = data.get_height(Vector3(x, 0, z))
				if is_nan(h): continue
				
				# Pente
				var norm = data.get_normal(Vector3(x, h, z))
				var slope = norm.angle_to(Vector3.UP)
				
				var type = ""
				var f_val = forest_noise.get_noise_2d(x, z)
				
				if slope > 0.7: 
					if randf() > 0.9: type = "rock" # Slightly fewer rocks on slopes
				else:
					if f_val > 0.2: # BACK TO 0.2 (Original balanced density)
						if randf() < (f_val + 0.1): type = "tree" # Less aggressive chance
					else: 
						if h > height_scale * 0.7:
							if randf() > 0.95: type = "rock"
						elif randf() > 0.99: type = "rock"
				
				if type != "" and not assets[type].is_empty():
					# AIR WORLD SPECIFIC FILTERING
					var is_high_altitude = (h > height_scale * 0.7)
					var chosen_path = ""
					
					if is_high_altitude:
						# Filter for "Twisted" trees or "Round" rocks for Air World
						var air_candidates = []
						for p in assets[type]:
							var lower_p = p.to_lower()
							if type == "tree" and "twisted" in lower_p: air_candidates.append(p)
							if type == "rock" and "round" in lower_p: air_candidates.append(p)
						
						if not air_candidates.is_empty():
							chosen_path = air_candidates.pick_random()
						else:
							chosen_path = assets[type].pick_random() # Fallback
					else:
						chosen_path = assets[type].pick_random()

					if not batch.has(chosen_path): batch[chosen_path] = []
					
					# Transform
					var t = Transform3D()
					t.origin = Vector3(x, h, z)
					
					# FLOATING ROCKS LOGIC
					if is_high_altitude and type == "rock":
						if randf() > 0.3: # 70% chance to float
							t.origin.y += randf_range(5.0, 25.0) # Float between 5m and 25m
							t.basis = t.basis.scaled(Vector3.ONE * randf_range(2.0, 5.0)) # Giant floating rocks
							# Random Rotation for floating look
							t.basis = t.basis.rotated(Vector3.UP, randf()*TAU).rotated(Vector3.RIGHT, randf()*TAU)

					var up = Vector3.UP.lerp(norm, 0.5 if type == "tree" else 0.9).normalized()
					var right = up.cross(Vector3.FORWARD).normalized()
					var fwd = right.cross(up).normalized()
					
					# Apply base rotation if not already floated crazy
					if not (is_high_altitude and type == "rock"):
						if right.length_squared() > 0.01:
							t.basis = Basis(right, up, fwd)
						t = t.rotated(up, randf() * TAU)
						t = t.scaled(Vector3.ONE * randf_range(0.8, 1.5))
					
					batch[chosen_path].append(t)
	
	# Instanciation par batch (avec await)
	_update_ui("Instanciation des objets...", 90)
	await get_tree().process_frame
	
	var keys = batch.keys()
	for i in range(keys.size()):
		var path = keys[i]
		_create_multimesh(path, batch[path])
		# Yield every SINGLE type for total fluidity
		await get_tree().process_frame 
		
# --- UTILS ---

func _scan_assets_safe(root_path: String) -> Dictionary:
	var res = {"tree": [], "rock": []}
	
	# ITERATIVE STACK-BASED SCAN (Async to avoid freezing)
	var stack = [root_path]
	var processed_count = 0
	
	while not stack.is_empty():
		var current_path = stack.pop_back()
		# print("üìÇ Scanning: " + current_path) # DEBUG
		if not current_path.ends_with("/"): current_path += "/"
		
		var dir = DirAccess.open(current_path)
		if dir:
			dir.list_dir_begin()
			var file_name = dir.get_next()
			while file_name != "":
				if dir.current_is_dir():
					if file_name != "." and file_name != "..":
						stack.append(current_path + file_name)
				else:
					var l_name = file_name.to_lower()
					if l_name.ends_with(".glb") or l_name.ends_with(".gltf") or l_name.ends_with(".tscn") or l_name.ends_with(".obj") or l_name.ends_with(".fbx"):
						var full_path = current_path + file_name
						if "tree" in l_name or "palm" in l_name or "sapling" in l_name or "pine" in l_name:
							res["tree"].append(full_path)
						elif "rock" in l_name or "stone" in l_name or "pebble" in l_name or "boulder" in l_name:
							res["rock"].append(full_path)
				
				file_name = dir.get_next()
				
				# NON-BLOCKING YIELD
				processed_count += 1
				if processed_count % 10 == 0:
					_update_ui("Scan: " + file_name, 50) # Show life!
					await get_tree().process_frame
					
	return res

func _create_multimesh(path, transforms):
	if transforms.is_empty(): return
	var res = load(path)
	if not res: return
	
	var mesh: Mesh = null
	var material: Material = null
	
	if res is Mesh:
		mesh = res
	elif res is PackedScene:
		var temp = res.instantiate()
		
		# Robust search for Mesh AND its original Material
		var find_data_recursive = func(node: Node, search_func: Callable):
			if node is MeshInstance3D and node.mesh:
				var m = node.mesh
				# Capturer le mat√©riau de la premi√®re surface (souvent l'atlas principal)
				var mat = node.get_active_material(0)
				if not mat and m.get_surface_count() > 0:
					mat = m.surface_get_material(0)
				
				# Si plusieurs surfaces, on essaie de garder le mesh intact
				# Mais MultiMeshInstance3D ne peut avoir qu'UN materiau override.
				# La plupart des assets stylis√©s utilisent un Atlas.
				return [m, mat]
			for child in node.get_children():
				var result = search_func.call(child, search_func)
				if result: return result
			return null
		
		# Alternative: If it's a complex scene, we might want to keep it as a scene
		# but SafeGenerator uses MultiMesh for performance.
		var data_pair = find_data_recursive.call(temp, find_data_recursive)
		if data_pair:
			mesh = data_pair[0]
			material = data_pair[1]
		temp.free()
	
	if not mesh: 
		return
	
	var mmi = MultiMeshInstance3D.new()
	mmi.name = "MMI_" + path.get_file().get_basename()
	
	# Apply material if found
	if material:
		mmi.material_override = material
	
	var mm = MultiMesh.new()
	mm.transform_format = MultiMesh.TRANSFORM_3D
	mm.mesh = mesh
	mm.instance_count = transforms.size()
	mmi.multimesh = mm
	
	add_child(mmi)
	mmi.owner = get_tree().edited_scene_root # Pour sauvegarde sc√®ne
	
	for i in range(transforms.size()):
		mm.set_instance_transform(i, transforms[i])

func _ensure_data():
	if not terrain_node: return null
	
	# Si Reset forc√©, on ignore ce qui est charg√© dans la sc√®ne
	# Si Reset forc√©, on ignore ce qui est charg√© dans la sc√®ne
	if force_reset:
		print("‚ôªÔ∏è RESET FORC√â : On d√©tache les anciennes donn√©es...")
		terrain_node.set("data", null)
		terrain_node.set("storage", null)
		force_reset = false # <--- FIX: Emp√™che le reset multiple (ex: lors du TP)
		
	var d = terrain_node.get("data")
	if not d: d = terrain_node.get("storage")
	
	if not d:
		print("‚ú® Cr√©ation nouvelles donn√©es...")
		# Tenter l'instanciation directe (plus stable pour Godot 4)
		if ClassDB.class_exists("Terrain3DData"):
			d = ClassDB.instantiate("Terrain3DData")
		elif ClassDB.class_exists("Terrain3DStorage"):
			d = ClassDB.instantiate("Terrain3DStorage")
		
		# SI TOUJOURS RIEN, ON TENTE NEW()
		if not d:
			var addon_path = "res://addons/terrain_3d/src/Terrain3DData.gd"
			if FileAccess.file_exists(addon_path):
				var scr = load(addon_path)
				if scr: d = scr.new()
		
		if d:
			print("‚ú® Donn√©es cr√©√©es : ", d.get_class())
			terrain_node.set("data", d)
			terrain_node.set("storage", d)
		else:
			print("‚ùå IMPOSSIBLE D'INSTANCIER Terrain3DData ou Storage !")
			return null
		
		# 1. R√âCUP√âRER OU CR√âER
	var active_regions = []
	if d.has_method("get_regions_active"):
		active_regions = d.get_regions_active()
		
	# Fallback creation (GRID -1..1 for 9 regions - PERFECT BALANCE)
	if active_regions.is_empty():
		print("‚ö†Ô∏è Cr√©ation d'une grille 3x3 s√©curis√©e...")
		if d.has_method("add_region"):
			var r_size = 1024
			if d.has_method("get_region_size"): r_size = d.get_region_size()
			
			# Ensure Data has assets before region creation
			_ensure_theme_assets()
			
			for gx in range(-1, 2):
				for gy in range(-1, 2):
					var new_reg = ClassDB.instantiate("Terrain3DRegion")
					if new_reg:
						new_reg.set("location", Vector2i(gx, gy))
						
						# Explicitly force RF (8) format for height
						var img_h = Image.create(r_size, r_size, false, Image.FORMAT_RF)
						new_reg.set("height_map", img_h)
						
						# Base Grass Control (Index 3)
						var img_c = Image.create(r_size, r_size, false, Image.FORMAT_RGBA8)
						img_c.fill(Color(float(3)/255.0, 0, 0, 1)) 
						new_reg.set("control_map", img_c)
						
						d.add_region(new_reg)
			print("‚úÖ Grille 3x3 allou√©e.")
		else:
			d.call("add_region", Vector3(0,0,0))
				
	# Refresh
	if d.has_method("get_regions_active"): active_regions = d.get_regions_active()
			
	# V√âRIFICATION CRITIQUE
	if active_regions.is_empty():
		print("‚ùå ERREUR CRITIQUE: Echec cr√©ation r√©gion.")
		return null
	
	# FORCE ASSIGNMENT TO NODE
	if terrain_node:
		terrain_node.set("data", d)
		terrain_node.set("storage", d)
		
		if terrain_node.has_method("set_storage"): terrain_node.set_storage(d)
		print("üîó Data connect√©e & Checkerboard OFF.")
		
	return d

func _ensure_lighting():
	# 1. NETTOYAGE AGGRESSIF (Nuke all potential conflicts)
	if is_inside_tree():
		var scene_root = get_tree().edited_scene_root
		if not scene_root: scene_root = get_tree().root
		
		# Nuke ALL existing WorldEnvironments and Lights to avoid clashing
		for env in scene_root.find_children("*", "WorldEnvironment", true, false):
			env.queue_free()
		for light in scene_root.find_children("*", "DirectionalLight3D", true, false):
			# On garde √©ventuellement le soleil du joueur s'il en a un, 
			# mais ici on veut un contr√¥le total sur l'esth√©tique.
			light.queue_free()
			
	await get_tree().process_frame # Wait for cleanup
	
	# 2. SOLEIL ZENITHAL (Ultra puissant pour la visibilit√©)
	var sun = DirectionalLight3D.new()
	sun.name = "Sun_Gen"
	sun.rotation_degrees = Vector3(-50, 45, 0)
	sun.light_energy = 3.0 # Zenith power
	sun.light_indirect_energy = 2.0
	sun.light_color = Color("fff8e0") # Warm Sunlight
	sun.shadow_enabled = true
	sun.directional_shadow_mode = DirectionalLight3D.SHADOW_PARALLEL_4_SPLITS
	
	get_parent().add_child(sun)
	sun.owner = get_tree().edited_scene_root
	
	# 3. ENVIRONNEMENT GDSCRIPT (Autoritaire)
	var env_node = WorldEnvironment.new()
	env_node.name = "WorldEnvironment_Gen"
	get_parent().add_child(env_node)
	env_node.owner = get_tree().edited_scene_root
	
	var e = Environment.new()
	env_node.environment = e
	
	e.background_mode = Environment.BG_SKY
	var sky_mat = ProceduralSkyMaterial.new()
	sky_mat.sky_top_color = Color("#4ea1ff") # Vibrant Blue
	sky_mat.sky_horizon_color = Color("#b0e3ff")
	sky_mat.ground_bottom_color = Color("#111111")
	
	var sky_obj = Sky.new()
	sky_obj.sky_material = sky_mat
	e.sky = sky_obj
	
	# LIGHTING & PERFORMANCE (Optimized for Iris Xe - LOW SPEC)
	e.ambient_light_source = Environment.AMBIENT_SOURCE_SKY
	e.ambient_light_sky_contribution = 1.0
	e.tonemap_mode = Environment.TONE_MAPPER_LINEAR
	e.tonemap_exposure = 1.0
	
	# GLOW (Keep it, it's cheapish and pretty)
	e.glow_enabled = true
	e.glow_intensity = 0.2
	e.glow_bloom = 0.05
	
	# VOLUMETRIC FOG (DISABLED for FPS)
	e.volumetric_fog_enabled = false
	# e.volumetric_fog_density = 0.0 # OFF
	
	# SSAO (DISABLED for FPS)
	e.ssao_enabled = false
	# e.ssao_radius = 1.0
	
	# REFLECTIONS (Cheap)
	e.ssr_enabled = false
	
	print("‚òÄÔ∏è PERFORMANCE Lighting applied (No Fog/SSAO).")
	
func _spawn_towers(data):
	print("üóº Spawning Sheikah Towers...")
	var region_size = 1024
	if data.has_method("get_region_size"): region_size = data.get_region_size()
	
	# On place 1 tour par "Zone implicite" de 500x500m
	var tower_scene = load("res://Tools/MapTower.tscn")
	if not tower_scene: return
	
	var active_regions = []
	if data.has_method("get_regions_active"): active_regions = data.get_regions_active()
	
	# SPAWN TOWER NEAR PLAYER (DEBUG/CONVENIENCE)
	var t_near = tower_scene.instantiate()
	var h_near = data.get_height(Vector3(50, 0, 50))
	if not is_nan(h_near):
		t_near.position = Vector3(50, h_near, 50)
		t_near.tower_id = "Tower_Spawn_Near"
		add_child(t_near)
		t_near.owner = get_tree().edited_scene_root
		print("üóº Tour 'Proche' plac√©e en (50, 50)")

	for region in active_regions:
		var rx = region.x if region is Vector2i else region.get_location().x
		var ry = region.y if region is Vector2i else region.get_location().y
		
		var center_x = rx * region_size + region_size / 2.0
		var center_z = ry * region_size + region_size / 2.0
		
		# Place 1 tower exactly in the center of the region for now
		var tx = center_x
		var tz = center_z
		var h = data.get_height(Vector3(tx, 0, tz))
		if is_nan(h): continue
		
		var t = tower_scene.instantiate()
		t.position = Vector3(tx, h, tz)
		t.tower_id = "Tower_" + str(rx) + "_" + str(ry)
		add_child(t)
		t.owner = get_tree().edited_scene_root
		print("üóº Tower placed at: ", t.position)

func _ensure_theme_assets():
	if not terrain_node: return
	# FIX: Ne pas return si les assets existent mais sont vides !
	# FORCE RELOAD ASSETS (User reports white textures)
	# if terrain_node.assets and terrain_node.assets.get_texture_count() > 0: 
	# 	print("üé® Assets d√©j√† charg√©s (" + str(terrain_node.assets.get_texture_count()) + "). Skip.")
	# 	return 
	
	print("üé® (Re)Chargement des Textures Zelda...")
	
	var assets_res = ClassDB.instantiate("Terrain3DAssets")
	if not assets_res:
		print("‚ö†Ô∏è Impossible d'instancier Terrain3DAssets")
		return

	# Helper pour cr√©er une texture avec √©chelle UV
	var _create_tex = func(tex_name, path_color, scale = 0.5):
		print("üîç Tentative cr√©ation texture: " + tex_name)
		var tex = ClassDB.instantiate("Terrain3DTextureAsset")
		if not tex: 
			print("‚ùå ECHEC Instantiation Terrain3DTextureAsset")
			return null
		
		tex.name = tex_name
		# DIAGNOSTIC: Force RED to see if textures are even sampled
		# tex.albedo_color = Color.RED if tex_name.contains("LAVA") else Color.WHITE # REMOVED DIAGNOSTIC RED
		tex.albedo_color = Color.WHITE # Restore full textures
		tex.uv_scale = scale
		
		# ROBUST LOADING: Convert to Image and generate mipmaps to avoid Format Mismatch/Missing Mipmap warnings
		var load_tex_safe = func(p):
			if not ResourceLoader.exists(p): return null
			var t = load(p)
			if not t: return null
			var img = t.get_image()
			if not img: return null
			if img.is_compressed(): img.decompress()
			img.convert(Image.FORMAT_RGBA8) 
			# V√âRIFICATION TAILLE (Terrain3D est tr√®s strict sur 1024)
			if img.get_width() != 1024 or img.get_height() != 1024:
				img.resize(1024, 1024, Image.INTERPOLATE_LANCZOS)
			img.generate_mipmaps()
			var itex = ImageTexture.create_from_image(img)
			return itex

		var t_albedo = load_tex_safe.call(path_color)
		if t_albedo:
			print("   ‚úÖ Image charg√©e: " + path_color)
			tex.albedo_texture = t_albedo
			
			# Auto-d√©tection normal map
			var path_normal = path_color.replace("_Color", "_NormalGL")
			if not ResourceLoader.exists(path_normal):
				path_normal = path_color.replace("_Color", "_Normal")
			
			var t_normal = load_tex_safe.call(path_normal)
			if t_normal: tex.normal_texture = t_normal
		else:
			print("‚ö†Ô∏è Fichier manquant ou √©chec: " + path_color)
			
		return tex

	var list = []
	var tex_data = [
		["GRASS_MAIN", "res://Assets/3D/Nature/Grass001_1K-JPG_Color.jpg", 0.2], # 0 
		["FOREST_STYLIZED", "res://Assets/3D/Nature/Stylized Nature MegaKit[Standard]/Textures/Leaves_NormalTree_C.png", 0.3], # 1
		["ICE_STYLIZED", "res://Assets/3D/Nature/Ice002_1K-JPG/Ice002_1K-JPG_Color.jpg", 0.8], # 2
		["GROUND_EARTH", "res://Assets/3D/Nature/Ground054_1K-JPG/Ground054_1K-JPG_Color.jpg", 0.3], # 3
		["RIVER_GRAVEL", "res://Assets/3D/Nature/Gravel040_1K-JPG/Gravel040_1K-JPG_Color.jpg", 0.5], # 4
		["DESERT_SAND", "res://Assets/3D/Nature/Stylized Nature MegaKit[Standard]/Textures/Rocks_Desert_Diffuse.png", 0.4], # 5
		["LAVA_STYLIZED", "res://Assets/3D/Nature/Lava004_1K-JPG/Lava004_1K-JPG_Color.jpg", 0.5], # 6
		["GOLDEN_WOODS", "res://Assets/3D/Nature/Stylized Nature MegaKit[Standard]/Textures/Leaves_TwistedTree_C.png", 0.5], # 7
		["CLIFF_ROCK", "res://Assets/3D/Nature/Rock030_1K-JPG/Rock030_1K-JPG_Color.jpg", 0.5], # 8
		["SNOW_STYLIZED", "res://Assets/3D/Nature/Snow003_1K-JPG/Snow003_1K-JPG_Color.jpg", 1.0] # 9
	]
	
	for entry in tex_data:
		var t = _create_tex.call(entry[0], entry[1], entry[2])
		if t: list.append(t)
	
	# API SAFE ASSIGNMENT
	if assets_res.has_method("set_textures"):
		print("üì¶ Methode set_textures trouv√©e")
		assets_res.call("set_textures", list)
	elif "texture_list" in assets_res:
		print("üì¶ Property texture_list trouv√©e")
		assets_res.texture_list = list
	else:
		print("üì¶ Property textures trouv√©e (set)")
		assets_res.set("textures", list)
		
	terrain_node.assets = assets_res
	
	# COLLISION FORCE (Pour l'escalade)
	if "collision_enabled" in terrain_node: terrain_node.set("collision_enabled", true)
	if "collision_mode" in terrain_node: terrain_node.set("collision_mode", 1) # Full Collision
	if "collision_layer" in terrain_node: terrain_node.set("collision_layer", 1)
	print("üì¶ Collision Terrain: Setup (Safe)")
	
	var d = terrain_node.get("data")
	if not d: d = terrain_node.get("storage")
	if d and "assets" in d: d.assets = assets_res # DUAL ASSIGNMENT
	
	# MATERIEL FORCE (Pour √©viter le blanc)
	var mat = terrain_node.get("material")
	if not mat:
		print("üì¶ Assignation Terrain3DMaterial...")
		mat = Terrain3DMaterial.new()
		terrain_node.set("material", mat)
	
	mat.set("shading_mode", 1) # 1 = Lit (Full PBR)
	mat.set("albedo_color", Color(1, 1, 1, 1))
	mat.set("world_background", 0) # Background off
	# Force essential rendering (Disable DEBUG views)
	var props = {
		"show_region_grid": false, "show_instancer_grid": false, "show_vertex_grid": false,
		"show_contours": false, "show_navigation": false, "show_checkered": false,
		"show_grey": false, "show_jaggedness": false,
		"show_colormap": false, # DEBUG VIEW OFF
		"show_heightmap": false, 
		"show_roughmap": false, 
		"show_control_texture": false, 
		"show_texture_height": false, 
		"show_texture_normal": false,
		"show_texture_rough": false, 
		"show_autoshader": false # CRITICAL: Set to FALSE to see painted biomes
	}
	for p_name in props:
		if p_name in mat: mat.set(p_name, props[p_name])
	
	mat.set("world_background", 0)
			
	print("üì¶ Shading standard (PBR) restaur√©. Debug grids OFF. Autoshader OFF.")
	
	print("üì¶ Type Mat√©riel: " + str(mat.get_class()))
	
	if terrain_node.has_method("notify_property_list_changed"):
		terrain_node.notify_property_list_changed()
	print("‚úÖ Textures Biomes appliqu√©es.")
	
func _teleport_player():
	var p = get_tree().get_first_node_in_group("Player")
	if not p:
		p = get_parent().find_child("Player", true, false)
	
	if p:
		# FIX: Ne pas rappeler _ensure_data() qui pourrait trigger un reset !
		var d = terrain_node.get("data")
		if not d: d = terrain_node.get("storage")
		
		var h = 50.0 # Standard safe height
		if d and d.has_method("get_height"): 
			var ground_h = d.get_height(Vector3(0, 0, 0))
			if not is_nan(ground_h):
				# Always spawn at least 5 meters ABOVE the ground
				h = ground_h + 5.0
		
		# Ensure we are not underground (Safety check)
		if h < 5.0: h = 5.0 
				
		p.global_position = Vector3(0, h, 0)
		print("üìç Player TP: " + str(p.global_position))

# --- UI MANAGMENT ---

func _show_loading_screen():
	if _ui_instance: return
	if loading_screen_scene:
		_ui_instance = loading_screen_scene.instantiate()
		get_tree().root.call_deferred("add_child", _ui_instance)

func _hide_loading_screen():
	if _ui_instance:
		_ui_instance.queue_free()
		_ui_instance = null

func _update_ui(text, val):
	if _ui_instance and _ui_instance.has_method("update_status"):
		_ui_instance.update_status(text, val)

# --- EDITOR BUTTON ---
func _on_button_generate(val):
	if val and is_inside_tree():
		_start_safe_generation_sequence()

func _spawn_enemies_async(data):
	print("‚öîÔ∏è Spawning Enemies...")
	var region_size = 1024
	if data.has_method("get_region_size"): region_size = data.get_region_size()
	
	var script_enemy = load("res://Entities/Enemies/Enemy.gd")
	var scene_skeleton = load("res://Assets/3D/Monsters/Monster Pack Animated by Quaternius/FBX/Skeleton.fbx")
	var scene_slime = load("res://Assets/3D/Monsters/Monster Pack Animated by Quaternius/FBX/Slime.fbx")
	
	if not script_enemy or not scene_skeleton:
		print("‚ö†Ô∏è Missing Enemy assets via Load")
		return

	var active_regions = []
	if data.has_method("get_regions_active"): active_regions = data.get_regions_active()

	for region in active_regions:
		var rx = region.x if region is Vector2i else region.get_location().x
		var ry = region.y if region is Vector2i else region.get_location().y
		
		var start_x = rx * region_size
		var start_z = ry * region_size
		
		# Density: 1 enemy every ~50m
		for i in range(20): # 20 enemies per region
			# ANTI-FREEZE
			if i % 10 == 0: await get_tree().process_frame
			
			var x = start_x + randf() * region_size
			var z = start_z + randf() * region_size
			var h = data.get_height(Vector3(x, 0, z))
			
			if is_nan(h): continue
			
			# Don't spawn under water or too high
			if h < 0: continue 
			
			# Choose Type
			var is_slime = randf() > 0.5
			var model_scene = scene_slime if is_slime else scene_skeleton
			if not model_scene: model_scene = scene_skeleton
			
			# CONSTRUCT ENEMY
			var enemy = CharacterBody3D.new()
			enemy.name = "Enemy_Reg" + str(rx) + "_" + str(i)
			enemy.set_script(script_enemy)
			
			# Stats Scaler based on distance
			var dist = Vector2(x, z).length()
			var lvl = 1 + int(dist / 200.0) # +1 Level every 200m
			enemy.level = lvl
			enemy.enemy_name = "Slime" if is_slime else "Skeleton"
			
			# Visuals
			var vis = null
			if model_scene is PackedScene:
				vis = model_scene.instantiate()
			elif model_scene is Mesh:
				vis = MeshInstance3D.new()
				vis.mesh = model_scene
			
			if vis:
				vis.name = "Visuals"
				enemy.add_child(vis)
			else:
				print("‚ö†Ô∏è Impossible d'instancier le mod√®le de l'ennemi.")
				continue
			
			# Scale Model (FBX are often small/large)
			vis.scale = Vector3.ONE * 1.5 
			
			# Collider
			var col = CollisionShape3D.new()
			var cap = CapsuleShape3D.new()
			cap.radius = 0.5
			cap.height = 1.8
			col.shape = cap
			col.position.y = 0.9
			enemy.add_child(col)
			
			# 3D UI (Billboard Health)
			var label = Label3D.new()
			label.name = "HealthLabel"
			label.text = "Lvl " + str(lvl) + " " + enemy.enemy_name
			label.billboard = BaseMaterial3D.BILLBOARD_ENABLED
			label.position.y = 2.2
			label.font_size = 32
			label.outline_render_priority = 0
			# (Cleaned up)
			enemy.position = Vector3(x, h + 2.0, z)
			
			get_parent().add_child(enemy)
			enemy.owner = get_tree().edited_scene_root
			
	print("‚öîÔ∏è Enemies Spawned.")

func _force_disable_debugs(mat):
	if not mat: return
	var props = [
		"show_checkered", "show_colormap", "show_control_texture", "show_autoshader",
		"show_region_grid", "show_instancer_grid", "show_vertex_grid",
		"show_heightmap", "show_roughmap", "show_texture_height"
	]
	for p in props:
		mat.set(p, false)
